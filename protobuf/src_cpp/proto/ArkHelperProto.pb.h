// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/ArkHelperProto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fArkHelperProto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fArkHelperProto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fArkHelperProto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fArkHelperProto_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fArkHelperProto_2eproto;
class CSGetKitDataReq;
struct CSGetKitDataReqDefaultTypeInternal;
extern CSGetKitDataReqDefaultTypeInternal _CSGetKitDataReq_default_instance_;
class CSGetKitDataRes;
struct CSGetKitDataResDefaultTypeInternal;
extern CSGetKitDataResDefaultTypeInternal _CSGetKitDataRes_default_instance_;
class CSGetShopDataReq;
struct CSGetShopDataReqDefaultTypeInternal;
extern CSGetShopDataReqDefaultTypeInternal _CSGetShopDataReq_default_instance_;
class CSGetShopDataRes;
struct CSGetShopDataResDefaultTypeInternal;
extern CSGetShopDataResDefaultTypeInternal _CSGetShopDataRes_default_instance_;
class CSPlayerLoginReq;
struct CSPlayerLoginReqDefaultTypeInternal;
extern CSPlayerLoginReqDefaultTypeInternal _CSPlayerLoginReq_default_instance_;
class CSPlayerLoginRes;
struct CSPlayerLoginResDefaultTypeInternal;
extern CSPlayerLoginResDefaultTypeInternal _CSPlayerLoginRes_default_instance_;
class CSUpdatePlayerDataReq;
struct CSUpdatePlayerDataReqDefaultTypeInternal;
extern CSUpdatePlayerDataReqDefaultTypeInternal _CSUpdatePlayerDataReq_default_instance_;
class CSUpdatePlayerDataRes;
struct CSUpdatePlayerDataResDefaultTypeInternal;
extern CSUpdatePlayerDataResDefaultTypeInternal _CSUpdatePlayerDataRes_default_instance_;
class SServerOnlineNotify;
struct SServerOnlineNotifyDefaultTypeInternal;
extern SServerOnlineNotifyDefaultTypeInternal _SServerOnlineNotify_default_instance_;
class SServerOnlineNotify_Server;
struct SServerOnlineNotify_ServerDefaultTypeInternal;
extern SServerOnlineNotify_ServerDefaultTypeInternal _SServerOnlineNotify_Server_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CSGetKitDataReq* Arena::CreateMaybeMessage<::CSGetKitDataReq>(Arena*);
template<> ::CSGetKitDataRes* Arena::CreateMaybeMessage<::CSGetKitDataRes>(Arena*);
template<> ::CSGetShopDataReq* Arena::CreateMaybeMessage<::CSGetShopDataReq>(Arena*);
template<> ::CSGetShopDataRes* Arena::CreateMaybeMessage<::CSGetShopDataRes>(Arena*);
template<> ::CSPlayerLoginReq* Arena::CreateMaybeMessage<::CSPlayerLoginReq>(Arena*);
template<> ::CSPlayerLoginRes* Arena::CreateMaybeMessage<::CSPlayerLoginRes>(Arena*);
template<> ::CSUpdatePlayerDataReq* Arena::CreateMaybeMessage<::CSUpdatePlayerDataReq>(Arena*);
template<> ::CSUpdatePlayerDataRes* Arena::CreateMaybeMessage<::CSUpdatePlayerDataRes>(Arena*);
template<> ::SServerOnlineNotify* Arena::CreateMaybeMessage<::SServerOnlineNotify>(Arena*);
template<> ::SServerOnlineNotify_Server* Arena::CreateMaybeMessage<::SServerOnlineNotify_Server>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum CSPlayerLoginRes_LoginState : int {
  CSPlayerLoginRes_LoginState_SUCCESS = 0,
  CSPlayerLoginRes_LoginState_ERR_PASSWORD = 1,
  CSPlayerLoginRes_LoginState_NO_STEAMID = 2,
  CSPlayerLoginRes_LoginState_NO_PASSWORD = 3,
  CSPlayerLoginRes_LoginState_CSPlayerLoginRes_LoginState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CSPlayerLoginRes_LoginState_CSPlayerLoginRes_LoginState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CSPlayerLoginRes_LoginState_IsValid(int value);
constexpr CSPlayerLoginRes_LoginState CSPlayerLoginRes_LoginState_LoginState_MIN = CSPlayerLoginRes_LoginState_SUCCESS;
constexpr CSPlayerLoginRes_LoginState CSPlayerLoginRes_LoginState_LoginState_MAX = CSPlayerLoginRes_LoginState_NO_PASSWORD;
constexpr int CSPlayerLoginRes_LoginState_LoginState_ARRAYSIZE = CSPlayerLoginRes_LoginState_LoginState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CSPlayerLoginRes_LoginState_descriptor();
template<typename T>
inline const std::string& CSPlayerLoginRes_LoginState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CSPlayerLoginRes_LoginState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CSPlayerLoginRes_LoginState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CSPlayerLoginRes_LoginState_descriptor(), enum_t_value);
}
inline bool CSPlayerLoginRes_LoginState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CSPlayerLoginRes_LoginState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CSPlayerLoginRes_LoginState>(
    CSPlayerLoginRes_LoginState_descriptor(), name, value);
}
// ===================================================================

class CSPlayerLoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSPlayerLoginReq) */ {
 public:
  inline CSPlayerLoginReq() : CSPlayerLoginReq(nullptr) {}
  ~CSPlayerLoginReq() override;
  explicit constexpr CSPlayerLoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSPlayerLoginReq(const CSPlayerLoginReq& from);
  CSPlayerLoginReq(CSPlayerLoginReq&& from) noexcept
    : CSPlayerLoginReq() {
    *this = ::std::move(from);
  }

  inline CSPlayerLoginReq& operator=(const CSPlayerLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSPlayerLoginReq& operator=(CSPlayerLoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSPlayerLoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSPlayerLoginReq* internal_default_instance() {
    return reinterpret_cast<const CSPlayerLoginReq*>(
               &_CSPlayerLoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CSPlayerLoginReq& a, CSPlayerLoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CSPlayerLoginReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSPlayerLoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSPlayerLoginReq* New() const final {
    return new CSPlayerLoginReq();
  }

  CSPlayerLoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSPlayerLoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSPlayerLoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSPlayerLoginReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSPlayerLoginReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSPlayerLoginReq";
  }
  protected:
  explicit CSPlayerLoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamIDFieldNumber = 1,
    kPassWordFieldNumber = 2,
  };
  // optional string SteamID = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  const std::string& steamid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_steamid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_steamid();
  PROTOBUF_MUST_USE_RESULT std::string* release_steamid();
  void set_allocated_steamid(std::string* steamid);
  private:
  const std::string& _internal_steamid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_steamid(const std::string& value);
  std::string* _internal_mutable_steamid();
  public:

  // optional string PassWord = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:CSPlayerLoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr steamid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  friend struct ::TableStruct_proto_2fArkHelperProto_2eproto;
};
// -------------------------------------------------------------------

class CSPlayerLoginRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSPlayerLoginRes) */ {
 public:
  inline CSPlayerLoginRes() : CSPlayerLoginRes(nullptr) {}
  ~CSPlayerLoginRes() override;
  explicit constexpr CSPlayerLoginRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSPlayerLoginRes(const CSPlayerLoginRes& from);
  CSPlayerLoginRes(CSPlayerLoginRes&& from) noexcept
    : CSPlayerLoginRes() {
    *this = ::std::move(from);
  }

  inline CSPlayerLoginRes& operator=(const CSPlayerLoginRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSPlayerLoginRes& operator=(CSPlayerLoginRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSPlayerLoginRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSPlayerLoginRes* internal_default_instance() {
    return reinterpret_cast<const CSPlayerLoginRes*>(
               &_CSPlayerLoginRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CSPlayerLoginRes& a, CSPlayerLoginRes& b) {
    a.Swap(&b);
  }
  inline void Swap(CSPlayerLoginRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSPlayerLoginRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSPlayerLoginRes* New() const final {
    return new CSPlayerLoginRes();
  }

  CSPlayerLoginRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSPlayerLoginRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSPlayerLoginRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSPlayerLoginRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSPlayerLoginRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSPlayerLoginRes";
  }
  protected:
  explicit CSPlayerLoginRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CSPlayerLoginRes_LoginState LoginState;
  static constexpr LoginState SUCCESS =
    CSPlayerLoginRes_LoginState_SUCCESS;
  static constexpr LoginState ERR_PASSWORD =
    CSPlayerLoginRes_LoginState_ERR_PASSWORD;
  static constexpr LoginState NO_STEAMID =
    CSPlayerLoginRes_LoginState_NO_STEAMID;
  static constexpr LoginState NO_PASSWORD =
    CSPlayerLoginRes_LoginState_NO_PASSWORD;
  static inline bool LoginState_IsValid(int value) {
    return CSPlayerLoginRes_LoginState_IsValid(value);
  }
  static constexpr LoginState LoginState_MIN =
    CSPlayerLoginRes_LoginState_LoginState_MIN;
  static constexpr LoginState LoginState_MAX =
    CSPlayerLoginRes_LoginState_LoginState_MAX;
  static constexpr int LoginState_ARRAYSIZE =
    CSPlayerLoginRes_LoginState_LoginState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LoginState_descriptor() {
    return CSPlayerLoginRes_LoginState_descriptor();
  }
  template<typename T>
  static inline const std::string& LoginState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LoginState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LoginState_Name.");
    return CSPlayerLoginRes_LoginState_Name(enum_t_value);
  }
  static inline bool LoginState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LoginState* value) {
    return CSPlayerLoginRes_LoginState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // optional .CSPlayerLoginRes.LoginState State = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::CSPlayerLoginRes_LoginState state() const;
  void set_state(::CSPlayerLoginRes_LoginState value);
  private:
  ::CSPlayerLoginRes_LoginState _internal_state() const;
  void _internal_set_state(::CSPlayerLoginRes_LoginState value);
  public:

  // @@protoc_insertion_point(class_scope:CSPlayerLoginRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int state_;
  friend struct ::TableStruct_proto_2fArkHelperProto_2eproto;
};
// -------------------------------------------------------------------

class CSUpdatePlayerDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSUpdatePlayerDataReq) */ {
 public:
  inline CSUpdatePlayerDataReq() : CSUpdatePlayerDataReq(nullptr) {}
  ~CSUpdatePlayerDataReq() override;
  explicit constexpr CSUpdatePlayerDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSUpdatePlayerDataReq(const CSUpdatePlayerDataReq& from);
  CSUpdatePlayerDataReq(CSUpdatePlayerDataReq&& from) noexcept
    : CSUpdatePlayerDataReq() {
    *this = ::std::move(from);
  }

  inline CSUpdatePlayerDataReq& operator=(const CSUpdatePlayerDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSUpdatePlayerDataReq& operator=(CSUpdatePlayerDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSUpdatePlayerDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSUpdatePlayerDataReq* internal_default_instance() {
    return reinterpret_cast<const CSUpdatePlayerDataReq*>(
               &_CSUpdatePlayerDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CSUpdatePlayerDataReq& a, CSUpdatePlayerDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CSUpdatePlayerDataReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSUpdatePlayerDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSUpdatePlayerDataReq* New() const final {
    return new CSUpdatePlayerDataReq();
  }

  CSUpdatePlayerDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSUpdatePlayerDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSUpdatePlayerDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSUpdatePlayerDataReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSUpdatePlayerDataReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSUpdatePlayerDataReq";
  }
  protected:
  explicit CSUpdatePlayerDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSUpdatePlayerDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fArkHelperProto_2eproto;
};
// -------------------------------------------------------------------

class CSUpdatePlayerDataRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSUpdatePlayerDataRes) */ {
 public:
  inline CSUpdatePlayerDataRes() : CSUpdatePlayerDataRes(nullptr) {}
  ~CSUpdatePlayerDataRes() override;
  explicit constexpr CSUpdatePlayerDataRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSUpdatePlayerDataRes(const CSUpdatePlayerDataRes& from);
  CSUpdatePlayerDataRes(CSUpdatePlayerDataRes&& from) noexcept
    : CSUpdatePlayerDataRes() {
    *this = ::std::move(from);
  }

  inline CSUpdatePlayerDataRes& operator=(const CSUpdatePlayerDataRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSUpdatePlayerDataRes& operator=(CSUpdatePlayerDataRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSUpdatePlayerDataRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSUpdatePlayerDataRes* internal_default_instance() {
    return reinterpret_cast<const CSUpdatePlayerDataRes*>(
               &_CSUpdatePlayerDataRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CSUpdatePlayerDataRes& a, CSUpdatePlayerDataRes& b) {
    a.Swap(&b);
  }
  inline void Swap(CSUpdatePlayerDataRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSUpdatePlayerDataRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSUpdatePlayerDataRes* New() const final {
    return new CSUpdatePlayerDataRes();
  }

  CSUpdatePlayerDataRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSUpdatePlayerDataRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSUpdatePlayerDataRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSUpdatePlayerDataRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSUpdatePlayerDataRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSUpdatePlayerDataRes";
  }
  protected:
  explicit CSUpdatePlayerDataRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVipFieldNumber = 1,
    kPointsFieldNumber = 2,
  };
  // optional int32 Vip = 1;
  bool has_vip() const;
  private:
  bool _internal_has_vip() const;
  public:
  void clear_vip();
  ::PROTOBUF_NAMESPACE_ID::int32 vip() const;
  void set_vip(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vip() const;
  void _internal_set_vip(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 Points = 2;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  ::PROTOBUF_NAMESPACE_ID::int32 points() const;
  void set_points(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_points() const;
  void _internal_set_points(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:CSUpdatePlayerDataRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 vip_;
  ::PROTOBUF_NAMESPACE_ID::int32 points_;
  friend struct ::TableStruct_proto_2fArkHelperProto_2eproto;
};
// -------------------------------------------------------------------

class CSGetShopDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSGetShopDataReq) */ {
 public:
  inline CSGetShopDataReq() : CSGetShopDataReq(nullptr) {}
  ~CSGetShopDataReq() override;
  explicit constexpr CSGetShopDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSGetShopDataReq(const CSGetShopDataReq& from);
  CSGetShopDataReq(CSGetShopDataReq&& from) noexcept
    : CSGetShopDataReq() {
    *this = ::std::move(from);
  }

  inline CSGetShopDataReq& operator=(const CSGetShopDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSGetShopDataReq& operator=(CSGetShopDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSGetShopDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSGetShopDataReq* internal_default_instance() {
    return reinterpret_cast<const CSGetShopDataReq*>(
               &_CSGetShopDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CSGetShopDataReq& a, CSGetShopDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CSGetShopDataReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSGetShopDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSGetShopDataReq* New() const final {
    return new CSGetShopDataReq();
  }

  CSGetShopDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSGetShopDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSGetShopDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSGetShopDataReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSGetShopDataReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSGetShopDataReq";
  }
  protected:
  explicit CSGetShopDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSGetShopDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fArkHelperProto_2eproto;
};
// -------------------------------------------------------------------

class CSGetShopDataRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSGetShopDataRes) */ {
 public:
  inline CSGetShopDataRes() : CSGetShopDataRes(nullptr) {}
  ~CSGetShopDataRes() override;
  explicit constexpr CSGetShopDataRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSGetShopDataRes(const CSGetShopDataRes& from);
  CSGetShopDataRes(CSGetShopDataRes&& from) noexcept
    : CSGetShopDataRes() {
    *this = ::std::move(from);
  }

  inline CSGetShopDataRes& operator=(const CSGetShopDataRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSGetShopDataRes& operator=(CSGetShopDataRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSGetShopDataRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSGetShopDataRes* internal_default_instance() {
    return reinterpret_cast<const CSGetShopDataRes*>(
               &_CSGetShopDataRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CSGetShopDataRes& a, CSGetShopDataRes& b) {
    a.Swap(&b);
  }
  inline void Swap(CSGetShopDataRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSGetShopDataRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSGetShopDataRes* New() const final {
    return new CSGetShopDataRes();
  }

  CSGetShopDataRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSGetShopDataRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSGetShopDataRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSGetShopDataRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSGetShopDataRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSGetShopDataRes";
  }
  protected:
  explicit CSGetShopDataRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShopDataFieldNumber = 1,
  };
  // optional string ShopData = 1;
  bool has_shopdata() const;
  private:
  bool _internal_has_shopdata() const;
  public:
  void clear_shopdata();
  const std::string& shopdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shopdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shopdata();
  PROTOBUF_MUST_USE_RESULT std::string* release_shopdata();
  void set_allocated_shopdata(std::string* shopdata);
  private:
  const std::string& _internal_shopdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shopdata(const std::string& value);
  std::string* _internal_mutable_shopdata();
  public:

  // @@protoc_insertion_point(class_scope:CSGetShopDataRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shopdata_;
  friend struct ::TableStruct_proto_2fArkHelperProto_2eproto;
};
// -------------------------------------------------------------------

class CSGetKitDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSGetKitDataReq) */ {
 public:
  inline CSGetKitDataReq() : CSGetKitDataReq(nullptr) {}
  ~CSGetKitDataReq() override;
  explicit constexpr CSGetKitDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSGetKitDataReq(const CSGetKitDataReq& from);
  CSGetKitDataReq(CSGetKitDataReq&& from) noexcept
    : CSGetKitDataReq() {
    *this = ::std::move(from);
  }

  inline CSGetKitDataReq& operator=(const CSGetKitDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSGetKitDataReq& operator=(CSGetKitDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSGetKitDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSGetKitDataReq* internal_default_instance() {
    return reinterpret_cast<const CSGetKitDataReq*>(
               &_CSGetKitDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CSGetKitDataReq& a, CSGetKitDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CSGetKitDataReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSGetKitDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSGetKitDataReq* New() const final {
    return new CSGetKitDataReq();
  }

  CSGetKitDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSGetKitDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSGetKitDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSGetKitDataReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSGetKitDataReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSGetKitDataReq";
  }
  protected:
  explicit CSGetKitDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSGetKitDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fArkHelperProto_2eproto;
};
// -------------------------------------------------------------------

class CSGetKitDataRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSGetKitDataRes) */ {
 public:
  inline CSGetKitDataRes() : CSGetKitDataRes(nullptr) {}
  ~CSGetKitDataRes() override;
  explicit constexpr CSGetKitDataRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSGetKitDataRes(const CSGetKitDataRes& from);
  CSGetKitDataRes(CSGetKitDataRes&& from) noexcept
    : CSGetKitDataRes() {
    *this = ::std::move(from);
  }

  inline CSGetKitDataRes& operator=(const CSGetKitDataRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSGetKitDataRes& operator=(CSGetKitDataRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSGetKitDataRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSGetKitDataRes* internal_default_instance() {
    return reinterpret_cast<const CSGetKitDataRes*>(
               &_CSGetKitDataRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CSGetKitDataRes& a, CSGetKitDataRes& b) {
    a.Swap(&b);
  }
  inline void Swap(CSGetKitDataRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSGetKitDataRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSGetKitDataRes* New() const final {
    return new CSGetKitDataRes();
  }

  CSGetKitDataRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSGetKitDataRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSGetKitDataRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSGetKitDataRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSGetKitDataRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSGetKitDataRes";
  }
  protected:
  explicit CSGetKitDataRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKitDataFieldNumber = 1,
  };
  // optional string KitData = 1;
  bool has_kitdata() const;
  private:
  bool _internal_has_kitdata() const;
  public:
  void clear_kitdata();
  const std::string& kitdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kitdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kitdata();
  PROTOBUF_MUST_USE_RESULT std::string* release_kitdata();
  void set_allocated_kitdata(std::string* kitdata);
  private:
  const std::string& _internal_kitdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kitdata(const std::string& value);
  std::string* _internal_mutable_kitdata();
  public:

  // @@protoc_insertion_point(class_scope:CSGetKitDataRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kitdata_;
  friend struct ::TableStruct_proto_2fArkHelperProto_2eproto;
};
// -------------------------------------------------------------------

class SServerOnlineNotify_Server final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SServerOnlineNotify.Server) */ {
 public:
  inline SServerOnlineNotify_Server() : SServerOnlineNotify_Server(nullptr) {}
  ~SServerOnlineNotify_Server() override;
  explicit constexpr SServerOnlineNotify_Server(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SServerOnlineNotify_Server(const SServerOnlineNotify_Server& from);
  SServerOnlineNotify_Server(SServerOnlineNotify_Server&& from) noexcept
    : SServerOnlineNotify_Server() {
    *this = ::std::move(from);
  }

  inline SServerOnlineNotify_Server& operator=(const SServerOnlineNotify_Server& from) {
    CopyFrom(from);
    return *this;
  }
  inline SServerOnlineNotify_Server& operator=(SServerOnlineNotify_Server&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SServerOnlineNotify_Server& default_instance() {
    return *internal_default_instance();
  }
  static inline const SServerOnlineNotify_Server* internal_default_instance() {
    return reinterpret_cast<const SServerOnlineNotify_Server*>(
               &_SServerOnlineNotify_Server_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SServerOnlineNotify_Server& a, SServerOnlineNotify_Server& b) {
    a.Swap(&b);
  }
  inline void Swap(SServerOnlineNotify_Server* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SServerOnlineNotify_Server* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SServerOnlineNotify_Server* New() const final {
    return new SServerOnlineNotify_Server();
  }

  SServerOnlineNotify_Server* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SServerOnlineNotify_Server>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SServerOnlineNotify_Server& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SServerOnlineNotify_Server& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SServerOnlineNotify_Server* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SServerOnlineNotify.Server";
  }
  protected:
  explicit SServerOnlineNotify_Server(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPortFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int32 port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool state = 3;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  bool state() const;
  void set_state(bool value);
  private:
  bool _internal_state() const;
  void _internal_set_state(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SServerOnlineNotify.Server)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  bool state_;
  friend struct ::TableStruct_proto_2fArkHelperProto_2eproto;
};
// -------------------------------------------------------------------

class SServerOnlineNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SServerOnlineNotify) */ {
 public:
  inline SServerOnlineNotify() : SServerOnlineNotify(nullptr) {}
  ~SServerOnlineNotify() override;
  explicit constexpr SServerOnlineNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SServerOnlineNotify(const SServerOnlineNotify& from);
  SServerOnlineNotify(SServerOnlineNotify&& from) noexcept
    : SServerOnlineNotify() {
    *this = ::std::move(from);
  }

  inline SServerOnlineNotify& operator=(const SServerOnlineNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline SServerOnlineNotify& operator=(SServerOnlineNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SServerOnlineNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const SServerOnlineNotify* internal_default_instance() {
    return reinterpret_cast<const SServerOnlineNotify*>(
               &_SServerOnlineNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SServerOnlineNotify& a, SServerOnlineNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(SServerOnlineNotify* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SServerOnlineNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SServerOnlineNotify* New() const final {
    return new SServerOnlineNotify();
  }

  SServerOnlineNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SServerOnlineNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SServerOnlineNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SServerOnlineNotify& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SServerOnlineNotify* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SServerOnlineNotify";
  }
  protected:
  explicit SServerOnlineNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SServerOnlineNotify_Server Server;

  // accessors -------------------------------------------------------

  enum : int {
    kAllServersFieldNumber = 1,
  };
  // repeated .SServerOnlineNotify.Server AllServers = 1;
  int allservers_size() const;
  private:
  int _internal_allservers_size() const;
  public:
  void clear_allservers();
  ::SServerOnlineNotify_Server* mutable_allservers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SServerOnlineNotify_Server >*
      mutable_allservers();
  private:
  const ::SServerOnlineNotify_Server& _internal_allservers(int index) const;
  ::SServerOnlineNotify_Server* _internal_add_allservers();
  public:
  const ::SServerOnlineNotify_Server& allservers(int index) const;
  ::SServerOnlineNotify_Server* add_allservers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SServerOnlineNotify_Server >&
      allservers() const;

  // @@protoc_insertion_point(class_scope:SServerOnlineNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SServerOnlineNotify_Server > allservers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fArkHelperProto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CSPlayerLoginReq

// optional string SteamID = 1;
inline bool CSPlayerLoginReq::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSPlayerLoginReq::has_steamid() const {
  return _internal_has_steamid();
}
inline void CSPlayerLoginReq::clear_steamid() {
  steamid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSPlayerLoginReq::steamid() const {
  // @@protoc_insertion_point(field_get:CSPlayerLoginReq.SteamID)
  return _internal_steamid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSPlayerLoginReq::set_steamid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 steamid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSPlayerLoginReq.SteamID)
}
inline std::string* CSPlayerLoginReq::mutable_steamid() {
  std::string* _s = _internal_mutable_steamid();
  // @@protoc_insertion_point(field_mutable:CSPlayerLoginReq.SteamID)
  return _s;
}
inline const std::string& CSPlayerLoginReq::_internal_steamid() const {
  return steamid_.Get();
}
inline void CSPlayerLoginReq::_internal_set_steamid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  steamid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSPlayerLoginReq::_internal_mutable_steamid() {
  _has_bits_[0] |= 0x00000001u;
  return steamid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSPlayerLoginReq::release_steamid() {
  // @@protoc_insertion_point(field_release:CSPlayerLoginReq.SteamID)
  if (!_internal_has_steamid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return steamid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CSPlayerLoginReq::set_allocated_steamid(std::string* steamid) {
  if (steamid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  steamid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), steamid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CSPlayerLoginReq.SteamID)
}

// optional string PassWord = 2;
inline bool CSPlayerLoginReq::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSPlayerLoginReq::has_password() const {
  return _internal_has_password();
}
inline void CSPlayerLoginReq::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSPlayerLoginReq::password() const {
  // @@protoc_insertion_point(field_get:CSPlayerLoginReq.PassWord)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSPlayerLoginReq::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSPlayerLoginReq.PassWord)
}
inline std::string* CSPlayerLoginReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:CSPlayerLoginReq.PassWord)
  return _s;
}
inline const std::string& CSPlayerLoginReq::_internal_password() const {
  return password_.Get();
}
inline void CSPlayerLoginReq::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSPlayerLoginReq::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSPlayerLoginReq::release_password() {
  // @@protoc_insertion_point(field_release:CSPlayerLoginReq.PassWord)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CSPlayerLoginReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CSPlayerLoginReq.PassWord)
}

// -------------------------------------------------------------------

// CSPlayerLoginRes

// optional .CSPlayerLoginRes.LoginState State = 1;
inline bool CSPlayerLoginRes::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSPlayerLoginRes::has_state() const {
  return _internal_has_state();
}
inline void CSPlayerLoginRes::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::CSPlayerLoginRes_LoginState CSPlayerLoginRes::_internal_state() const {
  return static_cast< ::CSPlayerLoginRes_LoginState >(state_);
}
inline ::CSPlayerLoginRes_LoginState CSPlayerLoginRes::state() const {
  // @@protoc_insertion_point(field_get:CSPlayerLoginRes.State)
  return _internal_state();
}
inline void CSPlayerLoginRes::_internal_set_state(::CSPlayerLoginRes_LoginState value) {
  _has_bits_[0] |= 0x00000001u;
  state_ = value;
}
inline void CSPlayerLoginRes::set_state(::CSPlayerLoginRes_LoginState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:CSPlayerLoginRes.State)
}

// -------------------------------------------------------------------

// CSUpdatePlayerDataReq

// -------------------------------------------------------------------

// CSUpdatePlayerDataRes

// optional int32 Vip = 1;
inline bool CSUpdatePlayerDataRes::_internal_has_vip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSUpdatePlayerDataRes::has_vip() const {
  return _internal_has_vip();
}
inline void CSUpdatePlayerDataRes::clear_vip() {
  vip_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CSUpdatePlayerDataRes::_internal_vip() const {
  return vip_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CSUpdatePlayerDataRes::vip() const {
  // @@protoc_insertion_point(field_get:CSUpdatePlayerDataRes.Vip)
  return _internal_vip();
}
inline void CSUpdatePlayerDataRes::_internal_set_vip(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  vip_ = value;
}
inline void CSUpdatePlayerDataRes::set_vip(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vip(value);
  // @@protoc_insertion_point(field_set:CSUpdatePlayerDataRes.Vip)
}

// optional int32 Points = 2;
inline bool CSUpdatePlayerDataRes::_internal_has_points() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSUpdatePlayerDataRes::has_points() const {
  return _internal_has_points();
}
inline void CSUpdatePlayerDataRes::clear_points() {
  points_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CSUpdatePlayerDataRes::_internal_points() const {
  return points_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CSUpdatePlayerDataRes::points() const {
  // @@protoc_insertion_point(field_get:CSUpdatePlayerDataRes.Points)
  return _internal_points();
}
inline void CSUpdatePlayerDataRes::_internal_set_points(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  points_ = value;
}
inline void CSUpdatePlayerDataRes::set_points(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_points(value);
  // @@protoc_insertion_point(field_set:CSUpdatePlayerDataRes.Points)
}

// -------------------------------------------------------------------

// CSGetShopDataReq

// -------------------------------------------------------------------

// CSGetShopDataRes

// optional string ShopData = 1;
inline bool CSGetShopDataRes::_internal_has_shopdata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSGetShopDataRes::has_shopdata() const {
  return _internal_has_shopdata();
}
inline void CSGetShopDataRes::clear_shopdata() {
  shopdata_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSGetShopDataRes::shopdata() const {
  // @@protoc_insertion_point(field_get:CSGetShopDataRes.ShopData)
  return _internal_shopdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSGetShopDataRes::set_shopdata(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 shopdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSGetShopDataRes.ShopData)
}
inline std::string* CSGetShopDataRes::mutable_shopdata() {
  std::string* _s = _internal_mutable_shopdata();
  // @@protoc_insertion_point(field_mutable:CSGetShopDataRes.ShopData)
  return _s;
}
inline const std::string& CSGetShopDataRes::_internal_shopdata() const {
  return shopdata_.Get();
}
inline void CSGetShopDataRes::_internal_set_shopdata(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  shopdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSGetShopDataRes::_internal_mutable_shopdata() {
  _has_bits_[0] |= 0x00000001u;
  return shopdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSGetShopDataRes::release_shopdata() {
  // @@protoc_insertion_point(field_release:CSGetShopDataRes.ShopData)
  if (!_internal_has_shopdata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return shopdata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CSGetShopDataRes::set_allocated_shopdata(std::string* shopdata) {
  if (shopdata != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  shopdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shopdata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CSGetShopDataRes.ShopData)
}

// -------------------------------------------------------------------

// CSGetKitDataReq

// -------------------------------------------------------------------

// CSGetKitDataRes

// optional string KitData = 1;
inline bool CSGetKitDataRes::_internal_has_kitdata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSGetKitDataRes::has_kitdata() const {
  return _internal_has_kitdata();
}
inline void CSGetKitDataRes::clear_kitdata() {
  kitdata_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSGetKitDataRes::kitdata() const {
  // @@protoc_insertion_point(field_get:CSGetKitDataRes.KitData)
  return _internal_kitdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSGetKitDataRes::set_kitdata(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 kitdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSGetKitDataRes.KitData)
}
inline std::string* CSGetKitDataRes::mutable_kitdata() {
  std::string* _s = _internal_mutable_kitdata();
  // @@protoc_insertion_point(field_mutable:CSGetKitDataRes.KitData)
  return _s;
}
inline const std::string& CSGetKitDataRes::_internal_kitdata() const {
  return kitdata_.Get();
}
inline void CSGetKitDataRes::_internal_set_kitdata(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  kitdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSGetKitDataRes::_internal_mutable_kitdata() {
  _has_bits_[0] |= 0x00000001u;
  return kitdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSGetKitDataRes::release_kitdata() {
  // @@protoc_insertion_point(field_release:CSGetKitDataRes.KitData)
  if (!_internal_has_kitdata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return kitdata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CSGetKitDataRes::set_allocated_kitdata(std::string* kitdata) {
  if (kitdata != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  kitdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kitdata,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CSGetKitDataRes.KitData)
}

// -------------------------------------------------------------------

// SServerOnlineNotify_Server

// optional string name = 1;
inline bool SServerOnlineNotify_Server::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SServerOnlineNotify_Server::has_name() const {
  return _internal_has_name();
}
inline void SServerOnlineNotify_Server::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SServerOnlineNotify_Server::name() const {
  // @@protoc_insertion_point(field_get:SServerOnlineNotify.Server.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SServerOnlineNotify_Server::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SServerOnlineNotify.Server.name)
}
inline std::string* SServerOnlineNotify_Server::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SServerOnlineNotify.Server.name)
  return _s;
}
inline const std::string& SServerOnlineNotify_Server::_internal_name() const {
  return name_.Get();
}
inline void SServerOnlineNotify_Server::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SServerOnlineNotify_Server::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SServerOnlineNotify_Server::release_name() {
  // @@protoc_insertion_point(field_release:SServerOnlineNotify.Server.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SServerOnlineNotify_Server::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SServerOnlineNotify.Server.name)
}

// optional int32 port = 2;
inline bool SServerOnlineNotify_Server::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SServerOnlineNotify_Server::has_port() const {
  return _internal_has_port();
}
inline void SServerOnlineNotify_Server::clear_port() {
  port_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SServerOnlineNotify_Server::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SServerOnlineNotify_Server::port() const {
  // @@protoc_insertion_point(field_get:SServerOnlineNotify.Server.port)
  return _internal_port();
}
inline void SServerOnlineNotify_Server::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  port_ = value;
}
inline void SServerOnlineNotify_Server::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:SServerOnlineNotify.Server.port)
}

// optional bool state = 3;
inline bool SServerOnlineNotify_Server::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SServerOnlineNotify_Server::has_state() const {
  return _internal_has_state();
}
inline void SServerOnlineNotify_Server::clear_state() {
  state_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SServerOnlineNotify_Server::_internal_state() const {
  return state_;
}
inline bool SServerOnlineNotify_Server::state() const {
  // @@protoc_insertion_point(field_get:SServerOnlineNotify.Server.state)
  return _internal_state();
}
inline void SServerOnlineNotify_Server::_internal_set_state(bool value) {
  _has_bits_[0] |= 0x00000004u;
  state_ = value;
}
inline void SServerOnlineNotify_Server::set_state(bool value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:SServerOnlineNotify.Server.state)
}

// -------------------------------------------------------------------

// SServerOnlineNotify

// repeated .SServerOnlineNotify.Server AllServers = 1;
inline int SServerOnlineNotify::_internal_allservers_size() const {
  return allservers_.size();
}
inline int SServerOnlineNotify::allservers_size() const {
  return _internal_allservers_size();
}
inline void SServerOnlineNotify::clear_allservers() {
  allservers_.Clear();
}
inline ::SServerOnlineNotify_Server* SServerOnlineNotify::mutable_allservers(int index) {
  // @@protoc_insertion_point(field_mutable:SServerOnlineNotify.AllServers)
  return allservers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SServerOnlineNotify_Server >*
SServerOnlineNotify::mutable_allservers() {
  // @@protoc_insertion_point(field_mutable_list:SServerOnlineNotify.AllServers)
  return &allservers_;
}
inline const ::SServerOnlineNotify_Server& SServerOnlineNotify::_internal_allservers(int index) const {
  return allservers_.Get(index);
}
inline const ::SServerOnlineNotify_Server& SServerOnlineNotify::allservers(int index) const {
  // @@protoc_insertion_point(field_get:SServerOnlineNotify.AllServers)
  return _internal_allservers(index);
}
inline ::SServerOnlineNotify_Server* SServerOnlineNotify::_internal_add_allservers() {
  return allservers_.Add();
}
inline ::SServerOnlineNotify_Server* SServerOnlineNotify::add_allservers() {
  ::SServerOnlineNotify_Server* _add = _internal_add_allservers();
  // @@protoc_insertion_point(field_add:SServerOnlineNotify.AllServers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SServerOnlineNotify_Server >&
SServerOnlineNotify::allservers() const {
  // @@protoc_insertion_point(field_list:SServerOnlineNotify.AllServers)
  return allservers_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CSPlayerLoginRes_LoginState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CSPlayerLoginRes_LoginState>() {
  return ::CSPlayerLoginRes_LoginState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fArkHelperProto_2eproto
